"""
.. module:: modlamp.sequences

.. moduleauthor:: modlab Alex Mueller ETH Zurich <alex.mueller@pharma.ethz.ch>

This module incorporates different classes to generate peptide sequences with different characteristics. The following
classes are available:

============================		===============================================================================
Class								Characteristics
============================		===============================================================================
:py:class:`Random`					Generates random sequences with a specified amino acid distribution.
:py:class:`Helices`					Generates presumed amphipathic helical sequences with a hydrophobic moment.
:py:class:`Kinked`					Generates presumed amphipathic helices with a kink (Pro residue).
:py:class:`Oblique`					Generates presumed oblique oriented sequences in presence of libid membranes.
:py:class:`Centrosymmetric`			Generates centrosymmetric sequences with a symmetry axis.
:py:class:`MixedLibrary`			Generates a mixed library of sequences of all other classes.
============================		===============================================================================

"""

import os
import random
import numpy as np
from core import mutate_AA, aminoacids, clean, save_fasta, filter_unnatural, template, filter_similarity
from itertools import cycle
from sklearn.utils import shuffle

__author__ = 'modlab'


class Centrosymmetric:
	"""
	Base class for peptide sequences produced out of 7 AA centro-symmetric blocks yielding peptides of length
	14 or 21 AA (2*7 or 3*7).
	This class incorporates methods to generate special peptide sequences with an overall presumed
	hydrophobic moment. Sequences are generated by centro-symmetric blocks of seven amino acids. Two or three blocks
	are added to build a final sequence of length 14 or 21 amino acids length. If the method :func:`generate_symmetric()`
	is used, two or three identical blocks are concatenated. If the method :func:`generate_asymmetric()` is used,
	two or three different blocks are concatenated.
	"""

	def __init__(self,seqnum=1):
		'''
		:param seqnum: number of sequences to generate
		:return: defined number of sequences to generate, empty list to store produced sequences
		'''
		aminoacids(self)
		self.seqnum = int(seqnum)

	def generate_symmetric(self):
		'''
		The :func:`generate_symmetric()` method generates overall symmetric sequences out of two or three blocks of
		identical centro-symmetric sequence blocks of 7 amino acids. The resulting sequence presumably has a large
		hydrophobic moment.

		:return: In *self.sequences*: centro-symmetric peptide sequences of the form [h,+,h,a,h,+,h] with h = hydrophobic AA, + = basic AA,
		  a = anchor AA (F,Y,W,(P)), sequence length is 14 or 21 AA
		:Example:

		>>> S = Centrosymmetric(5)
		>>> S.generate_symmetric()
		>>> S.sequences
		['ARIFIRAARIFIRA','GRIYIRGGRIYIRGGRIYIRG','IRGFGRIIRGFGRIIRGFGRI','GKAYAKGGKAYAKG','AKGYGKAAKGYGKAAKGYGKA']
		'''
		clean(self)
		for s in range(self.seqnum): #iterate over number of sequences to generate
			n = random.choice(range(2,4)) #number of sequence blocks to take (2 or 3)
			seq = ['X'] * 7 #template sequence AA list with length 7
			for a in range(7): #generate symmetric sequence block of 7 AA with an anchor in the middle
				if a == 0:
					seq[0] = random.choice(self.AA_hyd)
					seq[6] = seq[0]
				elif a == 1:
					seq[1] = random.choice(self.AA_basic)
					seq[5] = seq[1]
				elif a == 2:
					seq[2] = random.choice(self.AA_hyd)
					seq[4] = seq[2]
				elif a == 3:
					seq[3] = random.choice(self.AA_anchor)
				else:
					continue
			self.sequences.append(''.join(seq)*n)

	def generate_asymmetric(self):
		'''
		The :func:`generate_asymmetric()` method generates overall asymmetric sequences out of two or three blocks of
		different centro-symmetric sequence blocks of 7 amino acids. The resulting sequence presumably has a large
		hydrophobic	moment.

		:return: In *self.sequences*: a list of peptide sequences as strings of length 14 or 21
		:Example:

		>>> S = Centrosymmetric(5)
		>>> S.generate_asymmetric()
		>>> S.sequences
		['GRLFLRGAKGFGKAVRVWVRV','IKGWGKILKLYLKL','LKAYAKLVKAWAKVLRLFLRL','IRLWLRIIKAFAKI','LRIFIRLVKLWLKVIRLWLRI']
		'''
		clean(self)
		for s in range(self.seqnum): #iterate over number of sequences to generate
			n = random.choice(range(2,4)) #number of sequence blocks to take (2 or 3)
			seq = ['X'] * 7 #template sequence AA list with length 7
			self.blocks = list()
			for c in range(n):
				for a in range(7): #generate symmetric sequence block of 7 AA with an anchor in the middle
					if a == 0:
						seq[0] = random.choice(self.AA_hyd)
						seq[6] = seq[0]
					elif a == 1:
						seq[1] = random.choice(self.AA_basic)
						seq[5] = seq[1]
					elif a == 2:
						seq[2] = random.choice(self.AA_hyd)
						seq[4] = seq[2]
					elif a == 3:
						seq[3] = random.choice(self.AA_anchor)
					else:
						continue
				self.blocks.append(''.join(seq))
			self.sequences.append(''.join(self.blocks))

	def mutate_AA(self,nr,prob):
		"""
		Method to mutate with **prob** probability a **nr** of positions per sequence randomly.

		:param nr: number of mutations to perform per sequence
		:param prob: probability of mutating a sequence
		:return: In *self.sequences*: mutated sequences
		:Example:

		>>> S.sequences
		['IAKAGRAIIK']
		>>> S.mutate_AA(3,1)
		>>> S.sequences
		['NAKAGRAWIK']

		.. seealso:: :func:`modlamp.core.mutate_AA()`
		"""
		mutate_AA(self,nr,prob)

	def save_fasta(self,filename):
		"""
		Method for saving sequences in the instance self.sequences to a file in FASTA format.

		:param filename: output filename (ending .fasta)
		:return: a FASTA formatted file containing the generated sequences

		.. seealso:: :func:`modlamp.core.save_fasta()`
		"""
		save_fasta(self,filename)

	def filter_unnatrual(self):
		"""
		Method to filter out sequences with unnatural amino acids from :py:attr:`self.sequences` as well as duplicates.
		:return: Filtered sequence list in :py:attr:`self.sequences`

		.. seealso:: :func:`modlamp.core.filter_unnatural()`
		"""
		filter_unnatural(self)

	def filter_similarity(self, threshold=0.8):
		"""
		Method to filter out peptide sequences above a given similarity threshold in a list of all sequences in the class
		attribute :py:attr:`sequences`.
		:param threshold: Similarity threshold over which similar sequences are kicked out
		:return: Filtered sequence list in :py:attr:`self.sequences`

		.. seealso:: :func:`modlamp.core.filter_similarity()`
		"""
		filter_similarity(self, threshold)


class Helices:
	"""
	Base class for peptide sequences probable to form helices.
	This class incorporates methods for generating presumed amphipathic alpha-helical peptide sequences.
	These sequences are generated by placing basic residues along the sequence with distance 3-4 AA to each other.
	The remaining empty spots are filled up by hydrophobic AAs.
	"""
	def __init__(self,lenmin,lenmax,seqnum):
		'''
		:param lenmin: minimal sequence length
		:param lenmax: maximal sequence length
		:param seqnum: number of sequences to generate
		:return: defined variables as instances
		'''
		aminoacids(self)
		template(self,lenmin,lenmax,seqnum)

	def generate_helices(self):
		'''
		Method to generate amphipathic helical sequences with class features defined in :class:`Helices()`

		:return: In *self.sequences*: a list of sequences with presumed amphipathic helical structure.
		:Example:

		>>> H = Helices(7,21,5)
		>>> H.generate_helices()
		>>> H.sequences
		['KGIKVILKLAKAGVKAVRL','IILKVGKV','IAKAGRAIIK','LKILKVVGKGIRLIVRIIKAL','KAGKLVAKGAKVAAKAIKI']
		'''
		clean(self)
		for s in range(self.seqnum): #for the number of sequences to generate
			seq = ['X'] * random.choice(range(self.lenmin, self.lenmax + 1))
			basepos = random.choice(range(4)) #select spot for first basic residue from 0 to 3
			seq[basepos] = random.choice(self.AA_basic) #place first basic residue
			gap = cycle([3,4]).next #gap cycle of 3 & 4 --> 3,4,3,4,3,4...
			g = gap()
			while g+basepos < len(seq): #place more basic residues 3-4 positions further (changing between distance 3 and 4)
				basepos += g
				seq[basepos] = random.choice(self.AA_basic) #place more basic residues
				g = gap() #next gap

			for p in range(len(seq)):
				while seq[p] == 'X': #fill up remaining spots with hydrophobic AAs
					seq[p] = random.choice(self.AA_hyd)

			self.sequences.append(''.join(seq))

	def mutate_AA(self,nr,prob):
		"""
		Method to mutate with **prob** probability a **nr** of positions per sequence randomly.

		:param nr: number of mutations to perform per sequence
		:param prob: probability of mutating a sequence
		:return: In *self.sequences*: mutated sequences
		:Example:

		>>> H.sequences
		['IAKAGRAIIK']
		>>> H.mutate_AA(3,1)
		>>> H.sequences
		['NAKAGRAWIK']

		.. seealso:: :func:`modlamp.core.mutate_AA()`
		"""
		mutate_AA(self,nr,prob)

	def save_fasta(self,filename):
		"""
		Method for saving sequences in the instance self.sequences to a file in FASTA format.

		:param filename: output filename (ending .fasta)
		:return: a FASTA formatted file containing the generated sequences

		.. seealso:: :func:`modlamp.core.save_fasta()`
		"""
		save_fasta(self,filename)

	def filter_unnatrual(self):
		"""
		Method to filter out sequences with unnatural amino acids from :py:attr:`self.sequences` as well as duplicates.
		:return: Filtered sequence list in :py:attr:`self.sequences`

		.. seealso:: :func:`modlamp.core.filter_unnatural()`
		"""
		filter_unnatural(self)

	def filter_similarity(self, threshold=0.8):
		"""
		Method to filter out peptide sequences above a given similarity threshold in a list of all sequences in the class
		attribute :py:attr:`sequences`.
		:param threshold: Similarity threshold over which similar sequences are kicked out
		:return: Filtered sequence list in :py:attr:`self.sequences`

		.. seealso:: :func:`modlamp.core.filter_similarity()`
		"""
		filter_similarity(self, threshold)

class Kinked:
	"""
	Base class for peptide sequences probable to form helices with a kink.
	This class incorporates methods for presumed kinked amphipathic alpha-helical peptide sequences:
	Sequences are generated by placing basic residues along the sequence with distance 3-4 AA to each other.
	The remaining spots are filled up by hydrophobic AAs. Then, a basic residue is replaced by proline, presumably
	leading to a kink in the hydrophobic face of the amphipathic helices.
	"""
	def __init__(self,lenmin,lenmax,seqnum,):
		"""
		:param lenmin: minimal sequence length
		:param lenmax: maximal sequence length
		:param seqnum: number of sequences to generate
		:return: defined self variables
		"""
		aminoacids(self)
		template(self,lenmin,lenmax,seqnum)

	def generate_kinked(self):
		"""
		Method to actually generate the presumed kinked sequences with features defined in the class instances.

		:return: sequence list with strings stored in object.sequences
		:Example:

		>>> K = Kinked(7,28,8)
		>>> K.generate_kinked()
		>>> K.sequences
		['IILRLHPIG','ARGAKVAIKAIRGIAPGGRVVAKVVKVG','GGKVGRGVAFLVRIILK','KAVKALAKGAPVILCVAKVI',
		'IGIRVWRAVIKVIPVAVRGLRL','RIGRVIVPVIRGL','AKAARIVAMLAR','LGAKGWRLALKGIPAAIKLGKV']
		"""
		clean(self)
		for s in range(self.seqnum): #for the number of sequences to generate
			poslist = [] #used to
			seq = ['X'] * random.choice(range(self.lenmin, self.lenmax + 1))
			basepos = random.choice(range(4)) #select spot for first basic residue from 0 to 3
			seq[basepos] = random.choice(self.AA_basic) #place first basic residue
			poslist.append(basepos)
			gap = cycle([3,4]).next #gap cycle of 3 & 4 --> 3,4,3,4,3,4...
			g = gap()
			while g+basepos < len(seq): #place more basic residues 3-4 positions further (changing between distance 3 and 4)
				basepos += g
				seq[basepos] = random.choice(self.AA_basic) #place more basic residues
				g = gap() #next gap
				poslist.append(basepos)

			for p in range(len(seq)):
				while seq[p] == 'X': #fill up remaining spots with hydrophobic AAs
					seq[p] = random.choice(self.AA_hyd)

			#place proline around the middle of the sequence
			propos = poslist[len(poslist) / 2]
			seq[propos] = 'P'

			self.sequences.append(''.join(seq))

	def mutate_AA(self,nr,prob):
		"""
		Method to mutate with **prob** probability a **nr** of positions per sequence randomly.

		:param nr: number of mutations to perform per sequence
		:param prob: probability of mutating a sequence
		:return: In *self.sequences*: mutated sequences
		:Example:

		>>> S.sequences
		['IAKAGRAIIK']
		>>> S.mutate_AA(3,1)
		>>> S.sequences
		['NAKAGRAWIK']

		.. seealso:: :func:`modlamp.core.mutate_AA()`
		"""
		mutate_AA(self,nr,prob)

	def save_fasta(self,filename):
		"""
		Method for saving sequences in the instance self.sequences to a file in FASTA format.

		:param filename: output filename (ending .fasta)
		:return: a FASTA formatted file containing the generated sequences

		.. seealso:: :func:`modlamp.core.save_fasta()`
		"""
		save_fasta(self,filename)

	def filter_unnatrual(self):
		"""
		Method to filter out sequences with unnatural amino acids from :py:attr:`self.sequences` as well as duplicates.
		:return: Filtered sequence list in :py:attr:`self.sequences`

		.. seealso:: :func:`modlamp.core.filter_unnatural()`
		"""
		filter_unnatural(self)

	def filter_similarity(self, threshold=0.8):
		"""
		Method to filter out peptide sequences above a given similarity threshold in a list of all sequences in the class
		attribute :py:attr:`sequences`.
		:param threshold: Similarity threshold over which similar sequences are kicked out
		:return: Filtered sequence list in :py:attr:`self.sequences`

		.. seealso:: :func:`modlamp.core.filter_similarity()`
		"""
		filter_similarity(self, threshold)


class MixedLibrary:
	"""
	Base class for holding a virtual peptide library.
	This class :class:`MixedLibrary` incorporates methods to generate a virtual peptide library composed out of different
	sublibraries. The available library subtypes are all from the classes :class:`Centrosymmetric`,
	:class:`Helix`, :class:`Kinked`, :class:`Oblique` or :class:`Random`.
	"""

	def __init__(self,number,centrosymmetric=1,centroasymmetric=1,helix=1,kinked=1,oblique=1,rand=1,randAMP=1,randAMPnoCM=1):
		"""
		init method of the class :class:`MixedLibrary`. Except from **number**, all other parameters are ratios of
		sequences of the given sequence class.

		:param number: number of sequences to be generated
		:param centrosymmetric: ratio of symmetric centrosymmetric sequences in the library
		:param centroasymmetric: ratio of asymmetric centrosymmetric sequences in the library
		:param helix: ratio of amphipathic helical sequences in the library
		:param kinked: ratio of kinked amphipathic helical sequences in the library
		:param oblique: ratio of oblique oriented amphipathic helical sequences in the library
		:param random: ratio of random sequneces in the library
		:param randAMP: ratio of random sequences with APD2 amino acid distribution in the library
		:param randAMPnoCM: ratio of random sequences with APD2 amino acid distribution without Cys and Met in the library
		"""
		self.sequences = []
		self.number = int(number)
		self.norm = float(sum((centrosymmetric,centroasymmetric,helix,kinked,oblique,rand,randAMP,randAMPnoCM)))
		self.ratio_centrosym = float(centrosymmetric) / self.norm
		self.ratio_centroasym = float(centroasymmetric) / self.norm
		self.ratio_helix = float(helix) / self.norm
		self.ratio_kinked = float(kinked) / self.norm
		self.ratio_oblique = float(oblique) / self.norm
		self.ratio_rand = float(rand) / self.norm
		self.ratio_randAMP = float(randAMP) / self.norm
		self.ratio_randAMPnoCM = float(randAMPnoCM) / self.norm

	def generate_library(self):
		"""
		This method generates a virtual sequence library with the subtype ratios initialized in class :class:`MixedLibrary()`.
		All sequences are between 7 and 28 amino acids in length.

		:return: a virtual library of sequences in self.sequences
		:Example:

		>>> Lib = MixedLibrary(10000,centrosymmetric=5,centroasymmetric=5,helix=3,kinked=3,oblique=2,rand=10,randAMP=10,randAMPnoCM=5)
		>>> Lib.generate_library()
		>>> len(Lib.sequences)
		10000
		>>> Lib.sequences
		['RHTHVAGSWYGKMPPSPQTL','MRIKLRKIPCILAC','DGINKEVKDSYGVFLK','LRLYLRLGRVWVRG','GKLFLKGGKLFLKGGKLFLKG',...]
		>>> Lib.ratio_helix
		0.069767
		"""
		Cs = Centrosymmetric(round(float(self.number) * self.ratio_centrosym, ndigits=0))
		Cs.generate_symmetric()
		Ca = Centrosymmetric(round(float(self.number) * self.ratio_centroasym, ndigits=0))
		Ca.generate_asymmetric()
		H = Helices(7,28,round(float(self.number) * self.ratio_helix, ndigits=0))
		H.generate_helices()
		K = Kinked(7,28,round(float(self.number) * self.ratio_kinked, ndigits=0))
		K.generate_kinked()
		O = Oblique(7,28,round(float(self.number) * self.ratio_oblique, ndigits=0))
		O.generate_oblique()
		R = Random(7, 28, round(float(self.number) * self.ratio_rand, ndigits=0))
		R.generate_sequences('rand')
		Ra = Random(7, 28, round(float(self.number) * self.ratio_randAMP, ndigits=0))
		Ra.generate_sequences('AMP')
		Rc = Random(7, 28, round(float(self.number) * self.ratio_randAMPnoCM, ndigits=0))
		Rc.generate_sequences('AMPnoCM')

		self.sequences = Cs.sequences + Ca.sequences + H.sequences + K.sequences + O.sequences + R.sequences + Ra.sequences + Rc.sequences
		self.sequences = shuffle(self.sequences)

		# check if rounding affected sequence number. if too many: chop end off, if too few: fill up with random seqs
		if len(self.sequences) > self.number:
			self.sequences = self.sequences[:-(len(self.sequences)-self.number)]
		elif len(self.sequences) < self.number:
			S = Random(7, 28, self.number - len(self.sequences))
			S.generate_sequences()
			self.sequences = self.sequences + S.sequences

	def save_fasta(self,filename):
		"""
		Method for saving sequences in the instance self.sequences to a file in FASTA format.

		:param filename: output filename (ending .fasta)
		:return: a FASTA formatted file containing the generated sequences

		.. seealso:: :func:`modlamp.core.save_fasta()`
		"""
		save_fasta(self,filename)

	def filter_unnatrual(self):
		"""
		Method to filter out sequences with unnatural amino acids from :py:attr:`self.sequences` as well as duplicates.
		:return: Filtered sequence list in :py:attr:`self.sequences`

		.. seealso:: :func:`modlamp.core.filter_unnatural()`
		"""
		filter_unnatural(self)

	def filter_similarity(self, threshold=0.8):
		"""
		Method to filter out peptide sequences above a given similarity threshold in a list of all sequences in the class
		attribute :py:attr:`sequences`.
		:param threshold: Similarity threshold over which similar sequences are kicked out
		:return: Filtered sequence list in :py:attr:`self.sequences`

		.. seealso:: :func:`modlamp.core.filter_similarity()`
		"""
		filter_similarity(self, threshold)


class Oblique(object):
	"""
	Base class for oblique sequences with a so called linear hydrophobicity gradient.
	This module incorporates methods for generating peptide sequences with a linear hydrophobicity gradient, meaning that
	these sequences have a hydrophobic tail. This feature gives rise to the hypothesis that they orient themselves
	tilted/oblique in membrane environment.
	"""
	def __init__(self,lenmin,lenmax,seqnum):
		'''
		:param lenmin: minimal sequence length
		:param lenmax: maximal sequence length
		:param seqnum: number of sequences to generate
		:return: defined self variables
		'''
		aminoacids(self)
		template(self,lenmin,lenmax,seqnum)

	def generate_oblique(self):
		"""
		Method to generate the possible oblique sequences.
		:return: A list of sequences in self.sequences
		:Example:

		>>> O = Oblique(10,30,4)
		>>> O.generate_oblique()
		>>> O.sequences
		['GLLKVIRIAAKVLKVAVLVGIIAI','AIGKAGRLALKVIKVVIKVALILLAAVA','KILRAAARVIKGGIKAIVIL','VRLVKAIGKLLRIILRLARLAVGGILA']
		"""
		clean(self)
		for s in range(self.seqnum): #for the number of sequences to generate
			seq = ['X'] * random.choice(range(self.lenmin,self.lenmax + 1))
			basepos = random.choice(range(4)) #select spot for first basic residue from 0 to 3
			seq[basepos] = random.choice(self.AA_basic) #place first basic residue
			gap = cycle([3,4]).next #gap cycle of 3 & 4 --> 3,4,3,4,3,4...
			g = gap()
			while g+basepos < len(seq): #place more basic residues 3-4 positions further (changing between distance 3 and 4)
				basepos += g
				seq[basepos] = random.choice(self.AA_basic) #place more basic residues
				g = gap() #next gap

			for p in range(len(seq)):
				while seq[p] == 'X': #fill up remaining spots with hydrophobic AAs
					seq[p] = random.choice(self.AA_hyd)

			for e in range(1,len(seq)/3): # transform last 3rd of sequence into hydrophobic ones --> hydrophobicity gradient = oblique
				seq[-e] = random.choice(self.AA_hyd)

			self.sequences.append(''.join(seq))

	def mutate_AA(self,nr,prob):
		"""
		Method to mutate with **prob** probability a **nr** of positions per sequence randomly.

		:param nr: number of mutations to perform per sequence
		:param prob: probability of mutating a sequence
		:return: In *self.sequences*: mutated sequences
		:Example:

		>>> H.sequences
		['IAKAGRAIIK']
		>>> H.mutate_AA(3,1)
		>>> H.sequences
		['NAKAGRAWIK']

		.. seealso:: :func:`modlamp.core.mutate_AA()`
		"""
		mutate_AA(self,nr,prob)

	def save_fasta(self,filename):
		"""
		Method for saving sequences in the instance self.sequences to a file in FASTA format.

		:param filename: output filename (ending .fasta)
		:return: a FASTA formatted file containing the generated sequences

		.. seealso:: :func:`modlamp.core.save_fasta()`
		"""
		save_fasta(self,filename)

	def filter_unnatrual(self):
		"""
		Method to filter out sequences with unnatural amino acids from :py:attr:`self.sequences` as well as duplicates.
		:return: Filtered sequence list in :py:attr:`self.sequences`

		.. seealso:: :func:`modlamp.core.filter_unnatural()`
		"""
		filter_unnatural(self)

	def filter_similarity(self, threshold=0.8):
		"""
		Method to filter out peptide sequences above a given similarity threshold in a list of all sequences in the class
		attribute :py:attr:`sequences`.
		:param threshold: Similarity threshold over which similar sequences are kicked out
		:return: Filtered sequence list in :py:attr:`self.sequences`

		.. seealso:: :func:`modlamp.core.filter_similarity()`
		"""
		filter_similarity(self, threshold)


class Random:
	"""
	Class for random peptide sequences
	This class incorporates methods for generating peptide random peptide sequences of defined length.
	The amino acid probabilities can be chosen from different probabilities:

	- **rand**: equal probabilities for all amino acids
	- **AMP**: amino acid probabilities taken from the antimicrobial peptide database `APD3 <http://aps.unmc.edu/AP/statistic/statistic.php>`_, March 17, 2016.
	- **AMPnoCM**: same amino acid probabilities as **AMP** but lacking Cys and Met (for synthesizability)

	The probability values for all natural AA can be found in the following table:

	===	====	======	=========
	AA	rand	AMP		AMPnoCM
	===	====	======	=========
	A	0.05	0.0766	0.0812275
	C	0.05	0.071	0.0
	D	0.05	0.026	0.0306275
	E	0.05	0.0264	0.0310275
	F	0.05	0.0405	0.0451275
	G	0.05	0.1172	0.1218275
	H	0.05	0.021	0.0256275
	I	0.05	0.061	0.0656275
	K	0.05	0.0958	0.1004275
	L	0.05	0.0838	0.0884275
	M	0.05	0.0123	0.0
	N	0.05	0.0386	0.0432275
	P	0.05	0.0463	0.0509275
	Q	0.05	0.0251	0.0297275
	R	0.05	0.0545	0.0591275
	S	0.05	0.0613	0.0659275
	T	0.05	0.0455	0.0501275
	V	0.05	0.0572	0.0618275
	W	0.05	0.0155	0.0201275
	Y	0.05	0.0244	0.0290275
	===	====	======	=========

	"""

	def __init__(self, lenmin, lenmax, seqnum):
		"""
		:param lenmin: minimal sequence length
		:param lenmax: maximal sequence length
		:param seqnum: number of sequences to generate
		:return: initialized class attributes for sequence number and length
		"""
		aminoacids(self)
		template(self, lenmin, lenmax, seqnum)

	def generate_sequences(self,proba='rand'):
		"""
		:param proba: AA probability to be used to generate sequences. Available: AMP, AMPnoCM, rand
		:return: A list of random AMP sequences with defined AA probabilities
		:Example:

		>>> R = Random(5,20,6)
		>>> R.generate_sequences(proba='AMP')
		>>> R.sequences
		['CYGALWHIFV','NIVRHHAPSTVIK','LCPNPILGIV','TAVVRGKESLTP','GTGSVCKNSCRGRFGIIAF','VIIGPSYGDAEYA']
		"""
		clean(self)
		self.prob = self.prob_rand # default probability = rand
		if proba == 'AMPnoCM':
			self.prob = self.prob_AMPnoCM
		elif proba == 'AMP':
			self.prob = self.prob_AMP

		for s in range(self.seqnum):
			self.seq = []
			for l in range(random.choice(range(self.lenmin, self.lenmax+1))):
				self.seq.append(np.random.choice(self.AAs,p=self.prob)) #weighed random selection of amino acid, probabilities = prob
			self.sequences.append(''.join(self.seq))

	def save_fasta(self,filename):
		"""
		:param filename: output filename in which the sequences are safed in fasta format.
		:return: a fasta file containing the generated sequences

		.. seealso:: :func:`modlamp.core.save_fasta()`
		"""
		if os.path.exists(filename):
			os.remove(filename) #remove outputfile, it it exists
		o = open(filename, 'a')

		for n in range(len(self.sequences)):
			print >> o, '>Seq_' + str(n)
			print >> o, self.sequences[n]
		o.close()

	def mutate_AA(self,nr,prob):
		"""
		Method to mutate with **prob** probability a **nr** of positions per sequence randomly.

		:param nr: number of mutations to perform per sequence
		:param prob: probability of mutating a sequence
		:return: In *self.sequences*: mutated sequences
		:Example:

		>>> H.sequences
		['IAKAGRAIIK']
		>>> H.mutate_AA(3,1)
		>>> H.sequences
		['NAKAGRAWIK']

		.. seealso:: :func:`modlamp.core.mutate_AA()`
		"""
		mutate_AA(self,nr,prob)

	def filter_unnatrual(self):
		"""
		Method to filter out sequences with unnatural amino acids from :py:attr:`self.sequences` as well as duplicates.
		:return: Filtered sequence list in :py:attr:`self.sequences`

		.. seealso:: :func:`modlamp.core.filter_unnatural()`
		"""
		filter_unnatural(self)

	def filter_similarity(self, threshold=0.8):
		"""
		Method to filter out peptide sequences above a given similarity threshold in a list of all sequences in the class
		attribute :py:attr:`sequences`.
		:param threshold: Similarity threshold over which similar sequences are kicked out
		:return: Filtered sequence list in :py:attr:`self.sequences`

		.. seealso:: :func:`modlamp.core.filter_similarity()`
		"""
		filter_similarity(self, threshold)
