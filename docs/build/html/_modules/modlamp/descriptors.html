<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>modlamp.descriptors &mdash; modlamp v2.2.1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     'v2.2.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="modlamp v2.2.1 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">modlamp v2.2.1 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for modlamp.descriptors</h1><div class="highlight"><pre>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">.. module:: modlamp.descriptors</span>

<span class="sd">.. moduleauthor:: modlab Alex Mueller ETH Zurich &lt;alex.mueller@pharma.ethz.ch&gt;</span>

<span class="sd">This module incorporates different classes to calculate peptide descriptor values. The following classes are available:</span>

<span class="sd">=============================		============================================================================</span>
<span class="sd">Class								Characteristics</span>
<span class="sd">=============================		============================================================================</span>
<span class="sd">:py:class:`GlobalDescriptor`		Global one-dimensional peptide descriptors calculated from the AA sequence.</span>
<span class="sd">:py:class:`PeptideDescriptor`		AA scale based global or convoluted descriptors (auto-/cross-correlated).</span>
<span class="sd">=============================		============================================================================</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">core</span> <span class="kn">import</span> <span class="n">load_scale</span><span class="p">,</span> <span class="n">read_fasta</span><span class="p">,</span> <span class="n">save_fasta</span><span class="p">,</span> <span class="n">filter_unnatural</span><span class="p">,</span> <span class="n">filter_values</span><span class="p">,</span> <span class="n">filter_aa_more</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">MinMaxScaler</span><span class="p">,</span> <span class="n">StandardScaler</span>
<span class="kn">from</span> <span class="nn">sklearn.utils</span> <span class="kn">import</span> <span class="n">shuffle</span>
<span class="kn">from</span> <span class="nn">Bio.SeqUtils.ProtParam</span> <span class="kn">import</span> <span class="n">ProteinAnalysis</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s1">&#39;modlab&#39;</span>
<span class="n">__docformat__</span> <span class="o">=</span> <span class="s2">&quot;restructuredtext en&quot;</span>

<div class="viewcode-block" id="GlobalDescriptor"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.GlobalDescriptor">[docs]</a><span class="k">class</span> <span class="nc">GlobalDescriptor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Base class for global, non-amino acid scale dependant descriptors. The following descriptors can be calculated by</span>
<span class="sd">	the **methods** linked below:</span>

<span class="sd">	- `Sequence Charge 		&lt;modlamp.html#modlamp.descriptors.GlobalDescriptor.calculate_charge&gt;`_</span>
<span class="sd">	- `Molecular Weight		&lt;modlamp.html#modlamp.descriptors.GlobalDescriptor.calculate_MW&gt;`_</span>
<span class="sd">	- `Sequence Length		&lt;modlamp.html#modlamp.descriptors.GlobalDescriptor.length&gt;`_</span>
<span class="sd">	- `Isoelectric Point	&lt;modlamp.html#modlamp.descriptors.GlobalDescriptor.isoelectric_point&gt;`_</span>
<span class="sd">	- `Charge Density		&lt;modlamp.html#modlamp.descriptors.GlobalDescriptor.charge_density&gt;`_</span>
<span class="sd">	- `Hydrophobic Ratio	&lt;modlamp.html#modlamp.descriptors.GlobalDescriptor.hydrophobic_ratio&gt;`_</span>
<span class="sd">	- `Aromaticity			&lt;modlamp.html#modlamp.descriptors.GlobalDescriptor.aromaticity&gt;`_</span>
<span class="sd">	- `Boman Index			&lt;modlamp.html#modlamp.descriptors.GlobalDescriptor.boman_index&gt;`_</span>
<span class="sd">	- `Aliphatic Index		&lt;modlamp.html#modlamp.descriptors.GlobalDescriptor.aliphatic_index&gt;`_</span>
<span class="sd">	- `Instability Index	&lt;modlamp.html#modlamp.descriptors.GlobalDescriptor.instability_index&gt;`_</span>

<span class="sd">	Most of the methods calculate values with help of the :mod:`Bio.SeqUtils.ProtParam` module of `Biopython &lt;http://biopython.org/&gt;`_.</span>
<span class="sd">	&quot;&quot;&quot;</span>

<div class="viewcode-block" id="GlobalDescriptor.__init__"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.GlobalDescriptor.__init__">[docs]</a>	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seqs</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		:param seqs: a .fasta file with sequences, a list of sequences or a single sequence as string to calculate the descriptor values for.</span>
<span class="sd">		:return: initialized lists self.sequences, self.names and dictionary self.AA with amino acid scale values</span>
<span class="sd">		:Example:</span>

<span class="sd">		&gt;&gt;&gt; P = GlobalDescriptor(&#39;KLAKLAKKLAKLAK&#39;)</span>
<span class="sd">		&gt;&gt;&gt; P.sequences</span>
<span class="sd">		[&#39;KLAKLAKKLAKLAK&#39;]</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">D</span> <span class="o">=</span> <span class="n">PeptideDescriptor</span><span class="p">(</span><span class="n">seqs</span><span class="p">,</span> <span class="s1">&#39;eisenberg&#39;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">sequences</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">sequences</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">names</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">descriptor</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">target</span></div>

<div class="viewcode-block" id="GlobalDescriptor.length"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.GlobalDescriptor.length">[docs]</a>	<span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Method to calculate the length (total AA count) of every sequence in the attribute :py:attr:`sequences`.</span>

<span class="sd">		:param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the attribute :py:attr:`descriptor`.</span>
<span class="sd">		:return: array of sequence lengths in the attribute :py:attr:`descriptor`</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">:</span>
			<span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ProteinAnalysis</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">append</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span></div>

<div class="viewcode-block" id="GlobalDescriptor.calculate_MW"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.GlobalDescriptor.calculate_MW">[docs]</a>	<span class="k">def</span> <span class="nf">calculate_MW</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amide</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Method to calculate the molecular weight [g/mol] of every sequence in the attribute :py:attr:`sequences`.</span>

<span class="sd">		:param amide: {boolean} whether the sequences are C-terminally amidated (subtracts 0.95 from the MW).</span>
<span class="sd">		:param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the attribute :py:attr:`descriptor`.</span>
<span class="sd">		:return: array of descriptor values in the attribute :py:attr:`descriptor`</span>

<span class="sd">		.. versionchanged:: v2.1.5 amide option added</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">:</span>
			<span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ProteinAnalysis</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span><span class="o">.</span><span class="n">molecular_weight</span><span class="p">())</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">amide</span><span class="p">:</span>  <span class="c1"># if sequences are amidated, subtract 0.98 from calculated MW</span>
			<span class="n">desc</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">-</span><span class="mf">0.95</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">desc</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">append</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span></div>

	<span class="k">def</span> <span class="nf">_charge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">pH</span><span class="o">=</span><span class="mf">7.0</span><span class="p">,</span> <span class="n">amide</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Calculates charge of a single sequence. Adapted from Bio.SeqUtils.IsoelectricPoint.IsoelectricPoint_chargeR function.</span>
<span class="sd">		The method used is first described by Bjellqvist. In the case of amidation, the value for the &#39;Cterm&#39; pKa is 15 (and</span>
<span class="sd">		Cterm is added to the pos_pKs dictionary.</span>
<span class="sd">		The pKa scale is extracted from: http://www.hbcpnetbase.com/ (CRC Handbook of Chemistry and Physics, 96th edition).</span>
<span class="sd">		For further references, see the `Biopython &lt;http://biopython.org/&gt;`_ module :mod:`Bio.SeqUtils.IsoelectricPoint`.`</span>

<span class="sd">		pos_pKs = {&#39;Nterm&#39;: 9.38, &#39;K&#39;: 10.67, &#39;R&#39;: 12.10, &#39;H&#39;: 6.04}</span>
<span class="sd">		neg_pKs = {&#39;Cterm&#39;: 2.15, &#39;D&#39;: 3.71, &#39;E&#39;: 4.15, &#39;C&#39;: 8.14, &#39;Y&#39;: 10.10}</span>

<span class="sd">		:param pH: {float} pH at which to calculate peptide charge.</span>
<span class="sd">		:param amide: {boolean} whether the sequences have an amidated C-terminus.</span>
<span class="sd">		:return: {array} descriptor values in the attribute :py:attr:`descriptor</span>
<span class="sd">		&quot;&quot;&quot;</span>

		<span class="k">if</span> <span class="n">amide</span><span class="p">:</span>
			<span class="n">pos_pKs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Nterm&#39;</span><span class="p">:</span> <span class="mf">9.38</span><span class="p">,</span> <span class="s1">&#39;K&#39;</span><span class="p">:</span> <span class="mf">10.67</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">:</span> <span class="mf">12.10</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">:</span> <span class="mf">6.04</span><span class="p">}</span>
			<span class="n">neg_pKs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Cterm&#39;</span><span class="p">:</span> <span class="mf">15.</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="mf">3.71</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="mf">4.15</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="mf">8.14</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="mf">10.10</span><span class="p">}</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">pos_pKs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Nterm&#39;</span><span class="p">:</span> <span class="mf">9.38</span><span class="p">,</span> <span class="s1">&#39;K&#39;</span><span class="p">:</span> <span class="mf">10.67</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">:</span> <span class="mf">12.10</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">:</span> <span class="mf">6.04</span><span class="p">}</span>
			<span class="n">neg_pKs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Cterm&#39;</span><span class="p">:</span> <span class="mf">2.15</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="mf">3.71</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="mf">4.15</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="mf">8.14</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="mf">10.10</span><span class="p">}</span>

		<span class="n">aa_content</span> <span class="o">=</span> <span class="n">ProteinAnalysis</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span><span class="o">.</span><span class="n">count_amino_acids</span><span class="p">()</span>
		<span class="n">aa_content</span><span class="p">[</span><span class="s1">&#39;Nterm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
		<span class="n">aa_content</span><span class="p">[</span><span class="s1">&#39;Cterm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
		<span class="n">PositiveCharge</span> <span class="o">=</span> <span class="mf">0.0</span>
		<span class="k">for</span> <span class="n">aa</span><span class="p">,</span> <span class="n">pK</span> <span class="ow">in</span> <span class="n">pos_pKs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
			<span class="n">CR</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="n">pK</span> <span class="o">-</span> <span class="n">pH</span><span class="p">)</span>
			<span class="n">partial_charge</span> <span class="o">=</span> <span class="n">CR</span> <span class="o">/</span> <span class="p">(</span><span class="n">CR</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>
			<span class="n">PositiveCharge</span> <span class="o">+=</span> <span class="n">aa_content</span><span class="p">[</span><span class="n">aa</span><span class="p">]</span> <span class="o">*</span> <span class="n">partial_charge</span>
		<span class="n">NegativeCharge</span> <span class="o">=</span> <span class="mf">0.0</span>
		<span class="k">for</span> <span class="n">aa</span><span class="p">,</span> <span class="n">pK</span> <span class="ow">in</span> <span class="n">neg_pKs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
			<span class="n">CR</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="n">pH</span> <span class="o">-</span> <span class="n">pK</span><span class="p">)</span>
			<span class="n">partial_charge</span> <span class="o">=</span> <span class="n">CR</span> <span class="o">/</span> <span class="p">(</span><span class="n">CR</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>
			<span class="n">NegativeCharge</span> <span class="o">+=</span> <span class="n">aa_content</span><span class="p">[</span><span class="n">aa</span><span class="p">]</span> <span class="o">*</span> <span class="n">partial_charge</span>
		<span class="k">return</span> <span class="n">PositiveCharge</span> <span class="o">-</span> <span class="n">NegativeCharge</span>

<div class="viewcode-block" id="GlobalDescriptor.calculate_charge"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.GlobalDescriptor.calculate_charge">[docs]</a>	<span class="k">def</span> <span class="nf">calculate_charge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pH</span><span class="o">=</span><span class="mf">7.0</span><span class="p">,</span> <span class="n">amide</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Method to overall charge of every sequence in the attribute :py:attr:`sequences`.</span>
<span class="sd">		Adapted from Bio.SeqUtils.IsoelectricPoint.IsoelectricPoint_chargeR function.</span>

<span class="sd">		The method used is first described by Bjellqvist. In the case of amidation, the value for the &#39;Cterm&#39; pKa is 15 (and</span>
<span class="sd">		Cterm is added to the pos_pKs dictionary.</span>
<span class="sd">		The pKa scale is extracted from: http://www.hbcpnetbase.com/ (CRC Handbook of Chemistry and Physics, 96th edition).</span>
<span class="sd">		For further references, see the `Biopython &lt;http://biopython.org/&gt;`_ module :mod:`Bio.SeqUtils.IsoelectricPoint`.</span>

<span class="sd">			pos_pKs = {&#39;Nterm&#39;: 9.38, &#39;K&#39;: 10.67, &#39;R&#39;: 12.10, &#39;H&#39;: 6.04}</span>
<span class="sd">			neg_pKs = {&#39;Cterm&#39;: 2.15, &#39;D&#39;: 3.71, &#39;E&#39;: 4.15, &#39;C&#39;: 8.14, &#39;Y&#39;: 10.10}</span>

<span class="sd">		:param pH: {float} pH at which to calculate peptide charge.</span>
<span class="sd">		:param amide: {boolean} whether the sequences have an amidated C-terminus.</span>
<span class="sd">		:param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the attribute :py:attr:`descriptor`.</span>
<span class="sd">		:return: array of descriptor values in the attribute :py:attr:`descriptor`</span>
<span class="sd">		&quot;&quot;&quot;</span>

		<span class="n">desc</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">:</span>
			<span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_charge</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">pH</span><span class="p">,</span> <span class="n">amide</span><span class="p">))</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">append</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span></div>

<div class="viewcode-block" id="GlobalDescriptor.charge_density"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.GlobalDescriptor.charge_density">[docs]</a>	<span class="k">def</span> <span class="nf">charge_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pH</span><span class="o">=</span><span class="mf">7.0</span><span class="p">,</span> <span class="n">amide</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Method to calculate the charge density (charge / MW) of every sequences in the attributes :py:attr:`sequences`</span>

<span class="sd">		:param pH: {float} pH at which to calculate peptide charge.</span>
<span class="sd">		:param amide: {boolean} whether the sequences have an amidated C-terminus.</span>
<span class="sd">		:param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the attribute :py:attr:`descriptor`.</span>
<span class="sd">		:return: array of descriptor values in the attribute :py:attr:`descriptor`.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">calculate_charge</span><span class="p">(</span><span class="n">pH</span><span class="p">,</span> <span class="n">amide</span><span class="p">)</span>
		<span class="n">charges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">calculate_MW</span><span class="p">(</span><span class="n">amide</span><span class="p">)</span>
		<span class="n">masses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="n">charges</span> <span class="o">/</span> <span class="n">masses</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">append</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span></div>

<div class="viewcode-block" id="GlobalDescriptor.isoelectric_point"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.GlobalDescriptor.isoelectric_point">[docs]</a>	<span class="k">def</span> <span class="nf">isoelectric_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amide</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Method to calculate the isoelectric point of every sequence in the attribute :py:attr:`sequences`.</span>
<span class="sd">		The pK scale is extracted from: http://www.hbcpnetbase.com/ (CRC Handbook of Chemistry and Physics, 96th edition).</span>
<span class="sd">		The method used is based on the IsoelectricPoint module in `Biopython &lt;http://biopython.org/&gt;`_</span>
<span class="sd">		module :mod:`Bio.SeqUtils.ProtParam`.</span>

<span class="sd">			pos_pKs = {&#39;Nterm&#39;: 9.38, &#39;K&#39;: 10.67, &#39;R&#39;: 12.10, &#39;H&#39;: 6.04}</span>
<span class="sd">			neg_pKs = {&#39;Cterm&#39;: 2.15, &#39;D&#39;: 3.71, &#39;E&#39;: 4.15, &#39;C&#39;: 8.14, &#39;Y&#39;: 10.10}</span>

<span class="sd">		:param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the attribute :py:attr:`descriptor`.</span>
<span class="sd">		:return: array of descriptor values in the attribute :py:attr:`descriptor`</span>
<span class="sd">		&quot;&quot;&quot;</span>

		<span class="n">desc</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">:</span>

			<span class="c1"># Bracket between pH1 and pH2</span>
			<span class="n">pH</span> <span class="o">=</span> <span class="mf">7.0</span>
			<span class="n">charge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_charge</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">pH</span><span class="p">,</span> <span class="n">amide</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">charge</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
				<span class="n">pH1</span> <span class="o">=</span> <span class="n">pH</span>
				<span class="n">charge1</span> <span class="o">=</span> <span class="n">charge</span>
				<span class="k">while</span> <span class="n">charge1</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
					<span class="n">pH</span> <span class="o">=</span> <span class="n">pH1</span> <span class="o">+</span> <span class="mf">1.0</span>
					<span class="n">charge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_charge</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">pH</span><span class="p">,</span> <span class="n">amide</span><span class="p">)</span>
					<span class="k">if</span> <span class="n">charge</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
						<span class="n">pH1</span> <span class="o">=</span> <span class="n">pH</span>
						<span class="n">charge1</span> <span class="o">=</span> <span class="n">charge</span>
					<span class="k">else</span><span class="p">:</span>
						<span class="n">pH2</span> <span class="o">=</span> <span class="n">pH</span>
						<span class="n">charge2</span> <span class="o">=</span> <span class="n">charge</span>
						<span class="k">break</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">pH2</span> <span class="o">=</span> <span class="n">pH</span>
				<span class="n">charge2</span> <span class="o">=</span> <span class="n">charge</span>
				<span class="k">while</span> <span class="n">charge2</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
					<span class="n">pH</span> <span class="o">=</span> <span class="n">pH2</span> <span class="o">-</span> <span class="mf">1.0</span>
					<span class="n">charge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_charge</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">pH</span><span class="p">,</span> <span class="n">amide</span><span class="p">)</span>
					<span class="k">if</span> <span class="n">charge</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
						<span class="n">pH2</span> <span class="o">=</span> <span class="n">pH</span>
						<span class="n">charge2</span> <span class="o">=</span> <span class="n">charge</span>
					<span class="k">else</span><span class="p">:</span>
						<span class="n">pH1</span> <span class="o">=</span> <span class="n">pH</span>
						<span class="n">charge1</span> <span class="o">=</span> <span class="n">charge</span>
						<span class="k">break</span>
			<span class="c1"># Bisection</span>
			<span class="k">while</span> <span class="n">pH2</span> <span class="o">-</span> <span class="n">pH1</span> <span class="o">&gt;</span> <span class="mf">0.0001</span> <span class="ow">and</span> <span class="n">charge</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
				<span class="n">pH</span> <span class="o">=</span> <span class="p">(</span><span class="n">pH1</span> <span class="o">+</span> <span class="n">pH2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
				<span class="n">charge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_charge</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">pH</span><span class="p">,</span> <span class="n">amide</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">charge</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
					<span class="n">pH1</span> <span class="o">=</span> <span class="n">pH</span>
					<span class="n">charge1</span> <span class="o">=</span> <span class="n">charge</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">pH2</span> <span class="o">=</span> <span class="n">pH</span>
					<span class="n">charge2</span> <span class="o">=</span> <span class="n">charge</span>
			<span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pH</span><span class="p">)</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">append</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span></div>

<div class="viewcode-block" id="GlobalDescriptor.instability_index"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.GlobalDescriptor.instability_index">[docs]</a>	<span class="k">def</span> <span class="nf">instability_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Method to calculate the instability of every sequence in the attribute :py:attr:`sequences`.</span>
<span class="sd">		The instability index is a prediction of protein stability based on the amino acid composition.</span>
<span class="sd">		([1] K. Guruprasad, B. V Reddy, M. W. Pandit, Protein Eng. 1990, 4, 155–161.)</span>

<span class="sd">		:param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the attribute :py:attr:`descriptor`.</span>
<span class="sd">		:return: array of descriptor values in the attribute :py:attr:`descriptor`</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">:</span>
			<span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ProteinAnalysis</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span><span class="o">.</span><span class="n">instability_index</span><span class="p">())</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">append</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span></div>

<div class="viewcode-block" id="GlobalDescriptor.aromaticity"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.GlobalDescriptor.aromaticity">[docs]</a>	<span class="k">def</span> <span class="nf">aromaticity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Method to calculate the aromaticity of every sequence in the attribute :py:attr:`sequences`.</span>
<span class="sd">		According to Lobry, 1994, it is simply the relative frequency of Phe+Trp+Tyr.</span>

<span class="sd">		:param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the attribute :py:attr:`descriptor`.</span>
<span class="sd">		:return: array of descriptor values in the attribute :py:attr:`descriptor`</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">:</span>
			<span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ProteinAnalysis</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span><span class="o">.</span><span class="n">aromaticity</span><span class="p">())</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">append</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span></div>

<div class="viewcode-block" id="GlobalDescriptor.aliphatic_index"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.GlobalDescriptor.aliphatic_index">[docs]</a>	<span class="k">def</span> <span class="nf">aliphatic_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Method to calculate the aliphatic index of every sequence in the attribute :py:attr:`sequences`.</span>
<span class="sd">		According to Ikai, 1980, the aliphatic index is a measure of thermal stability of proteins and is dependant</span>
<span class="sd">		on the relative volume occupied by aliphatic amino acids (A,I,L &amp; V).</span>
<span class="sd">		([1] A. Ikai, J. Biochem. 1980, 88, 1895–1898.)</span>

<span class="sd">		:param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the attribute :py:attr:`descriptor`.</span>
<span class="sd">		:return: array of descriptor values in the attribute :py:attr:`descriptor`</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">:</span>
			<span class="n">d</span> <span class="o">=</span> <span class="n">ProteinAnalysis</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span><span class="o">.</span><span class="n">count_amino_acids</span><span class="p">()</span>
			<span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:(</span><span class="nb">float</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">))</span> <span class="o">*</span> <span class="mi">100</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>  <span class="c1"># get mole percent of all AA</span>
			<span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mf">2.9</span> <span class="o">*</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;V&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mf">3.9</span> <span class="o">*</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">]))</span>  <span class="c1"># formula for calculating the AI (Ikai, 1980)</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">append</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span></div>

<div class="viewcode-block" id="GlobalDescriptor.boman_index"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.GlobalDescriptor.boman_index">[docs]</a>	<span class="k">def</span> <span class="nf">boman_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Method to calculate the boman index of every sequence in the attribute :py:attr:`sequences`.</span>
<span class="sd">		According to Boman, 2003, the boman index is a measure for protein-protein interactions and is calculated by</span>
<span class="sd">		summing over all amino acid free energy of transfer [kcal/mol] between water and cyclohexane,[2] followed by</span>
<span class="sd">		dividing by	sequence length.</span>
<span class="sd">		([1] H. G. Boman, D. Wade, I. a Boman, B. Wåhlin, R. B. Merrifield, *FEBS Lett*. **1989**, *259*, 103–106.</span>
<span class="sd">		[2] A. Radzicka, R. Wolfenden, *Biochemistry* **1988**, *27*, 1664–1670.)</span>

<span class="sd">		:param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the attribute :py:attr:`descriptor`.</span>
<span class="sd">		:return: array of descriptor values in the attribute :py:attr:`descriptor`</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">D</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;L&#39;</span><span class="p">:</span><span class="o">-</span><span class="mf">4.92</span><span class="p">,</span><span class="s1">&#39;I&#39;</span><span class="p">:</span><span class="o">-</span><span class="mf">4.92</span><span class="p">,</span><span class="s1">&#39;V&#39;</span><span class="p">:</span><span class="o">-</span><span class="mf">4.04</span><span class="p">,</span><span class="s1">&#39;F&#39;</span><span class="p">:</span><span class="o">-</span><span class="mf">2.98</span><span class="p">,</span><span class="s1">&#39;M&#39;</span><span class="p">:</span><span class="o">-</span><span class="mf">2.35</span><span class="p">,</span><span class="s1">&#39;W&#39;</span><span class="p">:</span><span class="o">-</span><span class="mf">2.33</span><span class="p">,</span><span class="s1">&#39;A&#39;</span><span class="p">:</span><span class="o">-</span><span class="mf">1.81</span><span class="p">,</span><span class="s1">&#39;C&#39;</span><span class="p">:</span><span class="o">-</span><span class="mf">1.28</span><span class="p">,</span><span class="s1">&#39;G&#39;</span><span class="p">:</span><span class="o">-</span><span class="mf">0.94</span><span class="p">,</span><span class="s1">&#39;Y&#39;</span><span class="p">:</span><span class="mf">0.14</span><span class="p">,</span><span class="s1">&#39;T&#39;</span><span class="p">:</span><span class="mf">2.57</span><span class="p">,</span>
			 <span class="s1">&#39;S&#39;</span><span class="p">:</span><span class="mf">3.40</span><span class="p">,</span><span class="s1">&#39;H&#39;</span><span class="p">:</span><span class="mf">4.66</span><span class="p">,</span><span class="s1">&#39;Q&#39;</span><span class="p">:</span><span class="mf">5.54</span><span class="p">,</span><span class="s1">&#39;K&#39;</span><span class="p">:</span><span class="mf">5.55</span><span class="p">,</span><span class="s1">&#39;N&#39;</span><span class="p">:</span><span class="mf">6.64</span><span class="p">,</span><span class="s1">&#39;E&#39;</span><span class="p">:</span><span class="mf">6.81</span><span class="p">,</span><span class="s1">&#39;D&#39;</span><span class="p">:</span><span class="mf">8.72</span><span class="p">,</span><span class="s1">&#39;R&#39;</span><span class="p">:</span><span class="mf">14.92</span><span class="p">}</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">:</span>
			<span class="n">val</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">:</span>
				<span class="n">val</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
			<span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">append</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span></div>

<div class="viewcode-block" id="GlobalDescriptor.hydrophobic_ratio"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.GlobalDescriptor.hydrophobic_ratio">[docs]</a>	<span class="k">def</span> <span class="nf">hydrophobic_ratio</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Method to calculate the hydrophobic ratio of every sequence in the attribute :py:attr:`sequences`, which is the relative</span>
<span class="sd">		frequency of the amino acids [A,C,F,I,L,M &amp; V].</span>

<span class="sd">		:param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the attribute :py:attr:`descriptor`.</span>
<span class="sd">		:return: array of descriptor values in the attribute :py:attr:`descriptor`</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">:</span>
			<span class="n">pa</span> <span class="o">=</span> <span class="n">ProteinAnalysis</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span><span class="o">.</span><span class="n">count_amino_acids</span><span class="p">()</span>
			<span class="c1"># formula for calculating the AI (Ikai, 1980):</span>
			<span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pa</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">pa</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">pa</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">pa</span><span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">pa</span><span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">pa</span><span class="p">[</span><span class="s1">&#39;M&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">pa</span><span class="p">[</span><span class="s1">&#39;V&#39;</span><span class="p">])</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)))</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">append</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span></div>

<div class="viewcode-block" id="GlobalDescriptor.feature_scaling"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.GlobalDescriptor.feature_scaling">[docs]</a>	<span class="k">def</span> <span class="nf">feature_scaling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;standard&#39;</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Method for feature scaling of the calculated descriptor matrix.</span>

<span class="sd">		:param type: **&#39;standard&#39;** or **&#39;minmax&#39;**, type of scaling to be used</span>
<span class="sd">		:param fit: {boolean}, defines whether the used scaler is first fitting on the data (True) or</span>
<span class="sd">			whether the already fitted scaler in :py:attr:`scaler` should be used to transform (False).</span>
<span class="sd">		:return: scaled descriptor values in :py:attr`self.descriptor`</span>
<span class="sd">		:Example:</span>

<span class="sd">		&gt;&gt;&gt; D.descriptor</span>
<span class="sd">		array([[0.155],[0.34],[0.16235294],[-0.08842105],[0.116]])</span>
<span class="sd">		&gt;&gt;&gt; D.feature_scaling(type=&#39;minmax&#39;,fit=True)</span>
<span class="sd">		array([[0.56818182],[1.],[0.5853447],[0.],[0.47714988]])</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="s1">&#39;standard&#39;</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">scaler</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
			<span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span><span class="s1">&#39;minmax&#39;</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">scaler</span> <span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span>

			<span class="k">if</span> <span class="n">fit</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">)</span>
		<span class="k">except</span><span class="p">:</span>
			<span class="k">print</span> <span class="s2">&quot;Unknown scaler type!</span><span class="se">\n</span><span class="s2">Available: &#39;standard&#39;, &#39;minmax&#39;&quot;</span></div>

<div class="viewcode-block" id="GlobalDescriptor.feature_shuffle"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.GlobalDescriptor.feature_shuffle">[docs]</a>	<span class="k">def</span> <span class="nf">feature_shuffle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Method for shuffling features randomly.</span>

<span class="sd">		:return: descriptor matrix with shuffled feature columns in the attribute :py:attr:`descriptor`</span>
<span class="sd">		:Example:</span>

<span class="sd">		&gt;&gt;&gt; D.descriptor</span>
<span class="sd">		array([[0.80685625,167.05234375,39.56818125,-0.26338667,155.16888667,33.48778]])</span>
<span class="sd">		&gt;&gt;&gt; D.feature_shuffle()</span>
<span class="sd">		array([[155.16888667,-0.26338667,167.05234375,0.80685625,39.56818125,33.48778]])</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">shuffle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span></div>

<div class="viewcode-block" id="GlobalDescriptor.filter_values"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.GlobalDescriptor.filter_values">[docs]</a>	<span class="k">def</span> <span class="nf">filter_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s1">&#39;==&#39;</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Method to filter the descriptor matrix in the attribute :py:attr:`descriptor` for a given list of values (same</span>
<span class="sd">		size as the number of features in the descriptor matrix!) The operator option tells the method whether to</span>
<span class="sd">		filter for values equal, lower, higher ect. to the given values in the **values** array.</span>

<span class="sd">		:param values: List/array of values to filter</span>
<span class="sd">		:param operator: filter criterion, available are all SQL like operators: ``==``, ``&lt;``, ``&gt;``, ``&lt;=``and ``&gt;=``.</span>
<span class="sd">		:return: filtered descriptor matrix and updated sequences in the corresponding attributes.</span>

<span class="sd">		.. seealso:: :func:`modlamp.core.filter_values()`</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">filter_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">operator</span><span class="p">)</span></div>

<div class="viewcode-block" id="GlobalDescriptor.filter_aa"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.GlobalDescriptor.filter_aa">[docs]</a>	<span class="k">def</span> <span class="nf">filter_aa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aminoacids</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]):</span>
		<span class="sd">&quot;&quot;&quot;Method to filter sequences and corresponding descriptor values, if the sequences contain any of the given</span>
<span class="sd">		amino acids in the argument list **aminoacids**.</span>

<span class="sd">		:param aminoacids: List/array of amino acids to filter for</span>
<span class="sd">		:return: filtered descriptor matrix and updated sequences and names in the corresponding attributes.</span>

<span class="sd">		.. seealso:: :func:`modlamp.core.filter_aa_more()`</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">filter_aa_more</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aminoacids</span><span class="p">)</span></div>

<div class="viewcode-block" id="GlobalDescriptor.load_descriptordata"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.GlobalDescriptor.load_descriptordata">[docs]</a>	<span class="k">def</span> <span class="nf">load_descriptordata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="n">targets</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Method to load any data file with sequences and descriptor values and save it to a new insatnce of the</span>
<span class="sd">		class :class:`modlamp.descriptors.GlobalDescriptor`.</span>

<span class="sd">		.. note::</span>
<span class="sd">			The data file should **not** have any headers</span>

<span class="sd">		:param filename: filename of the data file to be loaded</span>
<span class="sd">		:param delimiter: column delimiter</span>
<span class="sd">		:param targets: {boolean} whether last column in the file contains a target class vector</span>
<span class="sd">		:return: loaded sequences, descriptor values and targets in the corresponding attributes.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="n">delimiter</span><span class="p">)</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span>  <span class="c1"># skip sequences as they are &quot;nan&quot; when read as float</span>
		<span class="n">seqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="n">delimiter</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;str&quot;</span><span class="p">)</span>
		<span class="n">seqs</span> <span class="o">=</span> <span class="n">seqs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">targets</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">sequences</span> <span class="o">=</span> <span class="n">seqs</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">data</span></div>

<div class="viewcode-block" id="GlobalDescriptor.save_descriptor"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.GlobalDescriptor.save_descriptor">[docs]</a>	<span class="k">def</span> <span class="nf">save_descriptor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">targets</span><span class="o">=</span><span class="p">[]):</span>
		<span class="sd">&quot;&quot;&quot;Method to save the descriptor values to a .csv/.txt file</span>

<span class="sd">		:param filename: filename of the output file</span>
<span class="sd">		:param delimiter: column delimiter</span>
<span class="sd">		:param targets: target class vector to be added to descriptor (same length as :py:attr:`sequences`)</span>
<span class="sd">		:return: output file with peptide names and descriptor values</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;|S80&#39;</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">targets</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">):</span>
			<span class="n">target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">targets</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
			<span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">target</span><span class="p">))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">))</span>
		<span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="n">delimiter</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="GlobalDescriptor.save_fasta"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.GlobalDescriptor.save_fasta">[docs]</a>	<span class="k">def</span> <span class="nf">save_fasta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputfile</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Method for saving sequences from :py:attr:`sequences` to a FASTA formatted file.</span>

<span class="sd">		:param outputfile: filename of the output FASTA file</span>
<span class="sd">		:return: list of sequences in self.sequences with corresponding sequence names in the attribute :py:attr:`names`</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">save_fasta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputfile</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="PeptideDescriptor"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.PeptideDescriptor">[docs]</a><span class="k">class</span> <span class="nc">PeptideDescriptor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Base class for peptide descriptors. The following **amino acid descriptor scales** are available for descriptor calculation:</span>

<span class="sd">	- **AASI**			(An amino acid selectivity index scale for helical antimicrobial peptides, *[1] D. Juretić, D. Vukicević, N. Ilić, N. Antcheva, A. Tossi, J. Chem. Inf. Model. 2009, 49, 2873–2882.*)</span>
<span class="sd">	- **argos**			(Argos hydrophobicity amino acid scale, *[2] P. Argos, J. K. M. Rao, P. A. Hargrave, Eur. J. Biochem. 2005, 128, 565–575.*)</span>
<span class="sd">	- **bulkiness**		(Amino acid side chain bulkiness scale, *[3] J. M. Zimmerman, N. Eliezer, R. Simha, J. Theor. Biol. 1968, 21, 170–201.*)</span>
<span class="sd">	- **charge_physio**	(Amino acid charge at pH 7.0 - Hystidine charge +0.1.)</span>
<span class="sd">	- **charge_acidic**	(Amino acid charge at acidic pH - Hystidine charge +1.0.)</span>
<span class="sd">	- **cougar**		(modlabs inhouse selection of global peptide descriptors)</span>
<span class="sd">	- **eisenberg**		(the Eisenberg hydrophobicity consensus amino acid scale, *[4] D. Eisenberg, R. M. Weiss, T. C. Terwilliger, W. Wilcox, Faraday Symp. Chem. Soc. 1982, 17, 109.*)</span>
<span class="sd">	- **Ez** 			(potential that assesses energies of insertion of amino acid side chains into lipid bilayers, *[5] A. Senes, D. C. Chadi, P. B. Law, R. F. S. Walters, V. Nanda, W. F. DeGrado, J. Mol. Biol. 2007, 366, 436–448.*)</span>
<span class="sd">	- **flexibility**	(amino acid side chain flexibilitiy scale, *[6] R. Bhaskaran, P. K. Ponnuswamy, Int. J. Pept. Protein Res. 1988, 32, 241–255.*)</span>
<span class="sd">	- **gravy**			(GRAVY hydrophobicity amino acid scale, *[7] J. Kyte, R. F. Doolittle, J. Mol. Biol. 1982, 157, 105–132.*)</span>
<span class="sd">	- **hopp-woods**	(Hopp-Woods amino acid hydrophobicity scale,*[8] T. P. Hopp, K. R. Woods, Proc. Natl. Acad. Sci. 1981, 78, 3824–3828.*)</span>
<span class="sd">	- **ISAECI**		(Isotropic Surface Area (ISA) and Electronic Charge Index (ECI) of amino acid side chains, *[9] E. R. Collantes, W. J. Dunn, J. Med. Chem. 1995, 38, 2705–2713.*)</span>
<span class="sd">	- **janin** 		(Janin hydrophobicity amino acid scale, [10] J. L. Cornette, K. B. Cease, H. Margalit, J. L. Spouge, J. A. Berzofsky, C. DeLisi, J. Mol. Biol. 1987, 195, 659–685.*)</span>
<span class="sd">	- **kytedoolittle**	(Kyte &amp; Doolittle hydrophobicity amino acid scale, *[11] J. Kyte, R. F. Doolittle, J. Mol. Biol. 1982, 157, 105–132.*)</span>
<span class="sd">	- **Levitt_alpha**	(Levitt amino acid alpha-helix propensity scale, extracted from http://web.expasy.org/protscale. *[12] M. Levitt, Biochemistry 1978, 17, 4277-4285.*)</span>
<span class="sd">	- **MSS**			(A graph-theoretical index that reflects topological shape and size of amino acid side chains, *[13] C. Raychaudhury, A. Banerjee, P. Bag, S. Roy, J. Chem. Inf. Comput. Sci. 1999, 39, 248–254.*)</span>
<span class="sd">	- **MSW**			(Amino acid scale based on a PCA of the molecular surface based WHIM descriptor (MS-WHIM), extended to natural amino acids, *[14] A. Zaliani, E. Gancia, J. Chem. Inf. Comput. Sci 1999, 39, 525–533.*)</span>
<span class="sd">	- **pepcats**		(modlabs pharmacophoric feature based PEPCATS scale, *[15] C. P. Koch, A. M. Perna, M. Pillong, N. K. Todoroff, P. Wrede, G. Folkers, J. A. Hiss, G. Schneider, PLoS Comput. Biol. 2013, 9, e1003088.*)</span>
<span class="sd">	- **polarity**		(Amino acid polarity scale, *[3] J. M. Zimmerman, N. Eliezer, R. Simha, J. Theor. Biol. 1968, 21, 170–201.*)</span>
<span class="sd">	- **PPCALI**		(modlabs inhouse scale derived from a PCA of 143 amino acid property scales, *[15] C. P. Koch, A. M. Perna, M. Pillong, N. K. Todoroff, P. Wrede, G. Folkers, J. A. Hiss, G. Schneider, PLoS Comput. Biol. 2013, 9, e1003088.*)</span>
<span class="sd">	- **refractivity**	(Relative amino acid refractivity values, *[16] T. L. McMeekin, M. Wilensky, M. L. Groves, Biochem. Biophys. Res. Commun. 1962, 7, 151–156.*)</span>
<span class="sd">	- **t_scale**		(A PCA derived scale based on amino acid side chain properties calculated with 6 different probes of the GRID program, *[17] M. Cocchi, E. Johansson, Quant. Struct. Act. Relationships 1993, 12, 1–8.*)</span>
<span class="sd">	- **TM_tend**		(Amino acid transmembrane propensity scale, extracted from http://web.expasy.org/protscale, *[18] Zhao, G., London E. Protein Sci. 2006, 15, 1987-2001.*)</span>
<span class="sd">	- **z3**			(The original three dimensional Z-scale, *[17] S. Hellberg, M. Sjöström, B. Skagerberg, S. Wold, J. Med. Chem. 1987, 30, 1126–1135.*)</span>
<span class="sd">	- **z5**			(The extended five dimensional Z-scale, *[18] M. Sandberg, L. Eriksson, J. Jonsson, M. Sjöström, S. Wold, J. Med. Chem. 1998, 41, 2481–2491.*)</span>

<span class="sd">	Further, amino acid scale independent methods can be calculated with help of the :class:`GlobalDescriptor` class.</span>

<span class="sd">	&quot;&quot;&quot;</span>

<div class="viewcode-block" id="PeptideDescriptor.__init__"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.PeptideDescriptor.__init__">[docs]</a>	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seqs</span><span class="p">,</span> <span class="n">scalename</span><span class="o">=</span><span class="s1">&#39;eisenberg&#39;</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		:param seqs: a .fasta file with sequences, a list of sequences or a single sequence as string to calculate the descriptor values for.</span>
<span class="sd">		:param scalename: name of the amino acid scale (one of the given list above) used to calculate the descriptor values</span>
<span class="sd">		:return: initialized attributes :py:attr:`sequences`, :py:attr:`names` and dictionary :py:attr:`scale` with amino acid scale values of the scale name in :py:attr:`scalename`.</span>
<span class="sd">		:Example:</span>

<span class="sd">		&gt;&gt;&gt; AMP = PeptideDescriptor(&#39;KLLKLLKKLLKLLK&#39;,&#39;pepcats&#39;)</span>
<span class="sd">		&gt;&gt;&gt; AMP.sequences</span>
<span class="sd">		[&#39;KLLKLLKKLLKLLK&#39;]</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">seqs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">sequences</span> <span class="o">=</span> <span class="n">seqs</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">seqs</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">sequences</span> <span class="o">=</span> <span class="n">seqs</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">seqs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span> <span class="ow">and</span> <span class="n">seqs</span><span class="o">.</span><span class="n">isupper</span><span class="p">():</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">sequences</span> <span class="o">=</span> <span class="p">[</span><span class="n">seqs</span><span class="p">]</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">seqs</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="n">read_fasta</span><span class="p">(</span><span class="n">seqs</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">print</span> <span class="s2">&quot;&#39;inputfile&#39; does not exist, is not a valid list of sequences or is not a valid sequence string&quot;</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">scalename</span> <span class="o">=</span> <span class="n">scalename</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">load_scale</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scalename</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[]])</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="PeptideDescriptor.load_scale"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.PeptideDescriptor.load_scale">[docs]</a>	<span class="k">def</span> <span class="nf">load_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scalename</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Method to load amino acid values from a given scale</span>

<span class="sd">		:param scalename: name of the amino acid scale to be loaded.</span>
<span class="sd">		:return: loaded amino acid scale values in a dictionary in the attribute :py:attr:`scale`.</span>

<span class="sd">		.. seealso:: :func:`modlamp.core.load_scale()`</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">load_scale</span><span class="p">(</span><span class="n">scalename</span><span class="p">)</span></div>

<div class="viewcode-block" id="PeptideDescriptor.read_fasta"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.PeptideDescriptor.read_fasta">[docs]</a>	<span class="k">def</span> <span class="nf">read_fasta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Method for loading sequences from a FASTA formatted file into the attributes :py:attr:`sequences` and</span>
<span class="sd">		:py:attr:`names`. This method is used by the base class :class:`PeptideDescriptor` if the input is a FASTA file.</span>

<span class="sd">		:param filename: .fasta file with sequences and headers to read</span>
<span class="sd">		:return: list of sequences in self.sequences with corresponding sequence names in self.names</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="n">read_fasta</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span></div>

<div class="viewcode-block" id="PeptideDescriptor.save_fasta"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.PeptideDescriptor.save_fasta">[docs]</a>	<span class="k">def</span> <span class="nf">save_fasta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputfile</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Method for saving sequences from :py:attr:`sequences` to a FASTA formatted file.</span>

<span class="sd">		:param outputfile: filename of the output FASTA file</span>
<span class="sd">		:return: list of sequences in self.sequences with corresponding sequence names in the attribute :py:attr:`names`</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">save_fasta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">outputfile</span><span class="p">)</span></div>

<div class="viewcode-block" id="PeptideDescriptor.calculate_autocorr"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.PeptideDescriptor.calculate_autocorr">[docs]</a>	<span class="k">def</span> <span class="nf">calculate_autocorr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Method for auto-correlating the amino acid values for a given descriptor scale</span>

<span class="sd">		:param window: correlation window for descriptor calculation in a sliding window approach</span>
<span class="sd">		:param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the attribute :py:attr:`descriptor`.</span>
<span class="sd">		:return: calculated descriptor numpy.array in self.descriptor</span>
<span class="sd">		:Example:</span>

<span class="sd">		&gt;&gt;&gt; AMP = PeptideDescriptor(&#39;GLFDIVKKVVGALGSL&#39;,&#39;PPCALI&#39;)</span>
<span class="sd">		&gt;&gt;&gt; AMP.calculate_autocorr(7)</span>
<span class="sd">		&gt;&gt;&gt; AMP.descriptor</span>
<span class="sd">		array([[  1.28442339e+00,   1.29025116e+00,   1.03240901e+00, .... ]])</span>
<span class="sd">		&gt;&gt;&gt; AMP.descriptor.shape</span>
<span class="sd">		(1, 133)</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">)):</span>  <span class="c1"># iterate over all sequences</span>
			<span class="n">seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
			<span class="n">M</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>  <span class="c1"># list of lists to store translated sequence values</span>
			<span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)):</span>  <span class="c1"># translate AA sequence into values</span>
				<span class="n">M</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">l</span><span class="p">])])</span>

			<span class="c1"># auto-correlation in defined sequence window</span>
			<span class="n">seqdesc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
			<span class="k">for</span> <span class="n">dist</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">window</span><span class="p">):</span>  <span class="c1"># for all correlation distances</span>
				<span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">])):</span>  <span class="c1"># for all features of the descriptor scale</span>
					<span class="n">valsum</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
					<span class="n">cntr</span> <span class="o">=</span> <span class="mf">0.</span>
					<span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)):</span>  <span class="c1"># for every position in the sequence</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">dist</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>  <span class="c1"># check if correlation distance is possible at that sequence position</span>
							<span class="n">cntr</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># counter to scale sum</span>
							<span class="n">valsum</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">val</span><span class="p">]</span> <span class="o">*</span> <span class="n">M</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="n">dist</span><span class="p">][</span><span class="n">val</span><span class="p">])</span>
					<span class="n">seqdesc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">valsum</span><span class="p">)</span> <span class="o">/</span> <span class="n">cntr</span><span class="p">)</span>  <span class="c1"># append scaled correlation distance values</span>

			<span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seqdesc</span><span class="p">)</span>  <span class="c1"># store final descriptor values in &quot;descriptor&quot;</span>
		<span class="k">if</span> <span class="n">append</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span></div>

<div class="viewcode-block" id="PeptideDescriptor.calculate_crosscorr"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.PeptideDescriptor.calculate_crosscorr">[docs]</a>	<span class="k">def</span> <span class="nf">calculate_crosscorr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Method for cross-correlating the amino acid values for a given descriptor scale</span>

<span class="sd">		:param window: correlation window for descriptor calculation in a sliding window approach</span>
<span class="sd">		:param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the attribute :py:attr:`descriptor`.</span>
<span class="sd">		:return: calculated descriptor numpy.array in self.descriptor</span>
<span class="sd">		:Example:</span>

<span class="sd">		&gt;&gt;&gt; AMP = PeptideDescriptor(&#39;GLFDIVKKVVGALGSL&#39;,&#39;pepcats&#39;)</span>
<span class="sd">		&gt;&gt;&gt; AMP.calculate_crosscorr(7)</span>
<span class="sd">		&gt;&gt;&gt; AMP.descriptor</span>
<span class="sd">		array([[ 0.6875    ,  0.46666667,  0.42857143,  0.61538462,  0.58333333, ... ]])</span>
<span class="sd">		&gt;&gt;&gt; AMP.descriptor.shape</span>
<span class="sd">		(1, 147)</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">)):</span>  <span class="c1"># iterate over all sequences</span>
			<span class="n">seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
			<span class="n">M</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>  <span class="c1"># list of lists to store translated sequence values</span>
			<span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)):</span>  <span class="c1"># translate AA sequence into values</span>
				<span class="n">M</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">l</span><span class="p">])])</span>

			<span class="c1"># auto-correlation in defined sequence window</span>
			<span class="n">seqdesc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
			<span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">])):</span>  <span class="c1"># for all features of the descriptor scale</span>
				<span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">])):</span>  <span class="c1"># for every feature cross correlation</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">+</span> <span class="n">cc</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span>
							<span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]):</span>  <span class="c1"># check if crosscorr distance is in range of the amount of features</span>
						<span class="k">for</span> <span class="n">dist</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">window</span><span class="p">):</span>  <span class="c1"># for all correlation distances</span>
							<span class="n">cntr</span> <span class="o">=</span> <span class="nb">float</span><span class="p">()</span>
							<span class="n">valsum</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
							<span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)):</span>  <span class="c1"># for every position in the sequence</span>
								<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">dist</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span>
										<span class="n">seq</span><span class="p">):</span>  <span class="c1"># check if correlation distance is possible at that sequence position</span>
									<span class="n">cntr</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># counter to scale sum</span>
									<span class="n">valsum</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">val</span><span class="p">]</span> <span class="o">*</span> <span class="n">M</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="n">dist</span><span class="p">][</span><span class="n">val</span> <span class="o">+</span> <span class="n">cc</span><span class="p">])</span>
							<span class="n">seqdesc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">valsum</span><span class="p">)</span> <span class="o">/</span> <span class="n">cntr</span><span class="p">)</span>  <span class="c1"># append scaled correlation distance values</span>

			<span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seqdesc</span><span class="p">)</span>  <span class="c1"># store final descriptor values in &quot;descriptor&quot;</span>
		<span class="k">if</span> <span class="n">append</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span></div>

<div class="viewcode-block" id="PeptideDescriptor.calculate_moment"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.PeptideDescriptor.calculate_moment">[docs]</a>	<span class="k">def</span> <span class="nf">calculate_moment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">modality</span><span class="o">=</span><span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Method for calculating the maximum or mean moment of the amino acid values for a given descriptor scale and window.</span>

<span class="sd">		:param window: {int} amino acid window in which to calculate the moment. If the sequence is shorter than the window, the length of the sequence is taken. So if the default window of 1000 is chosen, for all sequences shorter than 1000, the **global** hydrophobic moment will be calculated. Otherwise, the maximal hydrophiobic moment for the chosen window size found in the sequence will be returned.</span>
<span class="sd">		:param angle: {int} angle in which to calculate the moment. **100** for alpha helices, **180** for beta sheets.</span>
<span class="sd">		:param modality: {&#39;max&#39; or &#39;mean&#39;} Calculate respectively maximum or mean hydrophobic moment.</span>
<span class="sd">		:param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the attribute :py:attr:`descriptor`.</span>
<span class="sd">		:return: Calculated descriptor as a numpy.array in self.descriptor and all possible global values in self.all_moms (needed for calculate_profile method)</span>
<span class="sd">		:Example:</span>

<span class="sd">		&gt;&gt;&gt; AMP = PeptideDescriptor(&#39;GLFDIVKKVVGALGSL&#39;,&#39;eisenberg&#39;)</span>
<span class="sd">		&gt;&gt;&gt; AMP.calculate_moment(window=1000, angle=100, modality=&#39;max&#39;)</span>
<span class="sd">		&gt;&gt;&gt; AMP.descriptor</span>
<span class="sd">		array([[ 0.48790226]])</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
			<span class="k">print</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> Descriptor moment calculation is only possible for one dimensional descriptors.</span><span class="se">\n</span><span class="s1">&#39;</span>
			<span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>

		<span class="n">desc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">all_moms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">seq</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">):</span>
			<span class="n">wdw</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">))</span>  <span class="c1"># if sequence is shorter than window, take the whole sequence instead</span>
			<span class="n">M</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
			<span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)):</span>
				<span class="n">M</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">l</span><span class="p">])])</span>

			<span class="n">Mwdw</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
			<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">M</span><span class="p">)</span> <span class="o">-</span> <span class="n">wdw</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
				<span class="n">Mwdw</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">wdw</span><span class="p">],</span> <span class="p">[]))</span>

			<span class="n">Mwdw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Mwdw</span><span class="p">)</span>
			<span class="n">rads</span> <span class="o">=</span> <span class="n">angle</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">wdw</span><span class="p">))</span>  <span class="c1"># calculate actual moment (radial)</span>
			<span class="n">vcos</span> <span class="o">=</span> <span class="p">(</span><span class="n">Mwdw</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">rads</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">vsin</span> <span class="o">=</span> <span class="p">(</span><span class="n">Mwdw</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">rads</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">moms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">vsin</span> <span class="o">*</span> <span class="n">vsin</span> <span class="o">+</span> <span class="n">vcos</span> <span class="o">*</span> <span class="n">vcos</span><span class="p">)</span> <span class="o">/</span> <span class="n">wdw</span>

			<span class="k">if</span> <span class="n">modality</span> <span class="o">==</span> <span class="s1">&#39;max&#39;</span><span class="p">:</span>  <span class="c1"># take window with maximal value</span>
				<span class="n">moment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">moms</span><span class="p">)</span>
			<span class="k">elif</span> <span class="n">modality</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>  <span class="c1"># take average value over all windows</span>
				<span class="n">moment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">moms</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">print</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Modality parameter is wrong, please choose between &quot;max&quot; and &quot;mean&quot;.</span><span class="se">\n</span><span class="s1">&#39;</span>
				<span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>
			<span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">moment</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">all_moms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">moms</span><span class="p">)</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">append</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span></div>

<div class="viewcode-block" id="PeptideDescriptor.calculate_global"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.PeptideDescriptor.calculate_global">[docs]</a>	<span class="k">def</span> <span class="nf">calculate_global</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">modality</span><span class="o">=</span><span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Method for calculating a global / window averaging descriptor value of a given AA scale</span>

<span class="sd">		:param window: {int} amino acid window in which to calculate the moment. If the sequence is shorter than the window, the length of the sequence is taken.</span>
<span class="sd">		:param modality: {&#39;max&#39; or &#39;mean&#39;} Calculate respectively maximum or mean hydrophobic moment.</span>
<span class="sd">		:param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the attribute :py:attr:`descriptor`.</span>
<span class="sd">		:return: Calculated descriptor as numpy.array in self.descriptor and all possible global values in self.all_globs (needed for calculate_profile method)</span>
<span class="sd">		:Example:</span>

<span class="sd">		&gt;&gt;&gt; AMP = PeptideDescriptor(&#39;GLFDIVKKVVGALGSL&#39;,&#39;eisenberg&#39;)</span>
<span class="sd">		&gt;&gt;&gt; AMP.calculate_global(window=1000, modality=&#39;max&#39;)</span>
<span class="sd">		&gt;&gt;&gt; AMP.descriptor</span>
<span class="sd">		array([[ 0.44875]])</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">all_globs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">seq</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">):</span>
			<span class="n">wdw</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">))</span>
			<span class="n">M</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
			<span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)):</span>  <span class="c1"># translate AA sequence into values</span>
				<span class="n">M</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">l</span><span class="p">])])</span>
			<span class="n">Mwdw</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
			<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">M</span><span class="p">)</span> <span class="o">-</span> <span class="n">wdw</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
				<span class="n">Mwdw</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">wdw</span><span class="p">],[]))</span>  <span class="c1"># list of all the values for the different windows</span>
			<span class="n">Mwdw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Mwdw</span><span class="p">)</span>
			<span class="n">glob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Mwdw</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">wdw</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">modality</span> <span class="o">==</span> <span class="s1">&#39;max&#39;</span><span class="p">:</span>
					<span class="n">outglob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">glob</span><span class="p">)</span>  <span class="c1"># returned moment will be the maximum of all windows</span>
				<span class="k">elif</span> <span class="n">modality</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>
					<span class="n">outglob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">glob</span><span class="p">)</span>  <span class="c1"># returned moment will be the mean of all windows</span>
				<span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">outglob</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">all_globs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">glob</span><span class="p">)</span>

			<span class="k">except</span><span class="p">:</span>
				<span class="k">print</span> <span class="s1">&#39;Modality parameter is wrong, please choose between &quot;max&quot; and &quot;mean&quot;</span><span class="se">\n</span><span class="s1">.&#39;</span>

		<span class="n">desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">append</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span></div>

<div class="viewcode-block" id="PeptideDescriptor.calculate_profile"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.PeptideDescriptor.calculate_profile">[docs]</a>	<span class="k">def</span> <span class="nf">calculate_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;uH&#39;</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Method for calculating hydrophobicity or hydrophobic moment profiles for given sequences and fitting for slope and intercept. The hydrophobicity scale used is &quot;eisenberg&quot;</span>

<span class="sd">		:param type: type of profile, available: &#39;H&#39; for hydrophobicity or &#39;uH&#39; for hydrophobic moment</span>
<span class="sd">		:param window: {int} size of sliding window used (odd-numbered).</span>
<span class="sd">		:param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the attribute :py:attr:`descriptor`.</span>
<span class="sd">		:return: Fitted slope and intercept of calculated profile for every given sequence in self.descriptor</span>
<span class="sd">		:Example:</span>

<span class="sd">		&gt;&gt;&gt; AMP = PeptideDescriptor(&#39;KLLKLLKKVVGALG&#39;,&#39;kytedoolittle&#39;)</span>
<span class="sd">		&gt;&gt;&gt; AMP.calculate_profile(type=&#39;H&#39;)</span>
<span class="sd">		&gt;&gt;&gt; AMP.descriptor</span>
<span class="sd">		array([[ 0.03731293,  0.19246599]])</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="s1">&#39;uH&#39;</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">calculate_moment</span><span class="p">(</span><span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">y_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_moms</span>
		<span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s1">&#39;H&#39;</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">calculate_global</span><span class="p">(</span><span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">y_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_globs</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">print</span> <span class="s1">&#39;Type parameter is wrong, please choose between &quot;uH&quot; for hydrophobic moment and &quot;H&quot; for hydrophobicity</span><span class="se">\n</span><span class="s1">.&#39;</span>
			<span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>

		<span class="n">desc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">seq</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">x_vals</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">))[((</span><span class="n">window</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">):</span><span class="o">-</span><span class="p">((</span><span class="n">window</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)]</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">window</span><span class="p">:</span>
				<span class="n">slope</span><span class="p">,</span> <span class="n">intercept</span><span class="p">,</span> <span class="n">r_value</span><span class="p">,</span> <span class="n">p_value</span><span class="p">,</span> <span class="n">std_err</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">slope</span><span class="p">,</span> <span class="n">intercept</span><span class="p">,</span> <span class="n">r_value</span><span class="p">,</span> <span class="n">p_value</span><span class="p">,</span> <span class="n">std_err</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">linregress</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_vals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_vals</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
			<span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">slope</span><span class="p">,</span> <span class="n">intercept</span><span class="p">])</span>

		<span class="k">if</span> <span class="n">append</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span></div>

<div class="viewcode-block" id="PeptideDescriptor.count_aa"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.PeptideDescriptor.count_aa">[docs]</a>	<span class="k">def</span> <span class="nf">count_aa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="s1">&#39;relative&#39;</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Method for producing the amino acid distribution for the given sequences as a descriptor</span>

<span class="sd">		:param scale: {&#39;absolute&#39; or &#39;relative&#39;} defines whether counts or frequencies are given for each AA</span>
<span class="sd">		:param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the</span>
<span class="sd">			attribute :py:attr:`descriptor`.</span>
<span class="sd">		:return: the amino acid distributions for every sequence individually in the attribute :py:attr:`descriptor`</span>
<span class="sd">		:Example:</span>

<span class="sd">		&gt;&gt;&gt; AMP = PeptideDescriptor(&#39;ACDEFGHIKLMNPQRSTVWY&#39;,&#39;pepcats&#39;) # aa_count() does not depend on the descriptor scale</span>
<span class="sd">		&gt;&gt;&gt; AMP.count_aa()</span>
<span class="sd">		&gt;&gt;&gt; AMP.descriptor</span>
<span class="sd">		array([[ 0.05,  0.05,  0.05,  0.05,  0.05,  0.05,  0.05,  0.05,  0.05, ... ]])</span>
<span class="sd">		&gt;&gt;&gt; AMP.descriptor.shape</span>
<span class="sd">		(1, 20)</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
		<span class="n">scl</span> <span class="o">=</span> <span class="mi">1</span>
		<span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">scale</span> <span class="o">==</span> <span class="s1">&#39;relative&#39;</span><span class="p">:</span>
				<span class="n">scl</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
			<span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">seq</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="o">/</span> <span class="n">scl</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
			<span class="n">od</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
			<span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">od</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

		<span class="k">if</span> <span class="n">append</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span></div>

<div class="viewcode-block" id="PeptideDescriptor.feature_scaling"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.PeptideDescriptor.feature_scaling">[docs]</a>	<span class="k">def</span> <span class="nf">feature_scaling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;standard&#39;</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Method for feature scaling of the calculated descriptor matrix.</span>

<span class="sd">		:param type: {&#39;standard&#39; or &#39;minmax&#39;} type of scaling to be used</span>
<span class="sd">		:param fit: {boolean} defines whether the used scaler is first fitting on the data (True) or</span>
<span class="sd">			whether the already fitted scaler in :py:attr:`scaler` should be used to transform (False).</span>
<span class="sd">		:return: scaled descriptor values in :py:attr:`descriptor`</span>
<span class="sd">		:Example:</span>

<span class="sd">		&gt;&gt;&gt; D.descriptor</span>
<span class="sd">		array([[0.155],[0.34],[0.16235294],[-0.08842105],[0.116]])</span>
<span class="sd">		&gt;&gt;&gt; D.feature_scaling(type=&#39;minmax&#39;,fit=True)</span>
<span class="sd">		array([[0.56818182],[1.],[0.5853447],[0.],[0.47714988]])</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="s1">&#39;standard&#39;</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">scaler</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
			<span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span><span class="s1">&#39;minmax&#39;</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">scaler</span> <span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span>

			<span class="k">if</span> <span class="n">fit</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">)</span>
		<span class="k">except</span><span class="p">:</span>
			<span class="k">print</span> <span class="s2">&quot;Unknown scaler type!</span><span class="se">\n</span><span class="s2">Available: &#39;standard&#39;, &#39;minmax&#39;&quot;</span></div>

<div class="viewcode-block" id="PeptideDescriptor.feature_shuffle"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.PeptideDescriptor.feature_shuffle">[docs]</a>	<span class="k">def</span> <span class="nf">feature_shuffle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Method for shuffling feature columns randomly.</span>

<span class="sd">		:return: descriptor matrix with shuffled feature columns in :py:attr:`descriptor`</span>
<span class="sd">		:Example:</span>

<span class="sd">		&gt;&gt;&gt; D.descriptor</span>
<span class="sd">		array([[0.80685625,167.05234375,39.56818125,-0.26338667,155.16888667,33.48778]])</span>
<span class="sd">		&gt;&gt;&gt; D.feature_shuffle()</span>
<span class="sd">		array([[155.16888667,-0.26338667,167.05234375,0.80685625,39.56818125,33.48778]])</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">shuffle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span></div>

<span class="c1"># TODO move to core for both sequences and descriptors</span>

<div class="viewcode-block" id="PeptideDescriptor.sequence_order_shuffle"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.PeptideDescriptor.sequence_order_shuffle">[docs]</a>	<span class="k">def</span> <span class="nf">sequence_order_shuffle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Method for shuffling sequence order in self.sequences.</span>

<span class="sd">		:return: sequences in :py:attr`self.sequences` with shuffled order in the list.</span>
<span class="sd">		:Example:</span>

<span class="sd">		&gt;&gt;&gt; D.sequences</span>
<span class="sd">		[&#39;LILRALKGAARALKVA&#39;,&#39;VKIAKIALKIIKGLG&#39;,&#39;VGVRLIKGIGRVARGAI&#39;,&#39;LRGLRGVIRGGKAIVRVGK&#39;,&#39;GGKLVRLIARIGKGV&#39;]</span>
<span class="sd">		&gt;&gt;&gt; D.sequence_order_shuffle()</span>
<span class="sd">		&gt;&gt;&gt; D.sequences</span>
<span class="sd">		[&#39;VGVRLIKGIGRVARGAI&#39;,&#39;LILRALKGAARALKVA&#39;,&#39;LRGLRGVIRGGKAIVRVGK&#39;,&#39;GGKLVRLIARIGKGV&#39;,&#39;VKIAKIALKIIKGLG&#39;]</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">sequences</span> <span class="o">=</span> <span class="n">shuffle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">)</span></div>

<div class="viewcode-block" id="PeptideDescriptor.filter_unnatrual"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.PeptideDescriptor.filter_unnatrual">[docs]</a>	<span class="k">def</span> <span class="nf">filter_unnatrual</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Method to filter out sequences with unnatural amino acids from :py:attr:`sequences` as well as duplicates.</span>
<span class="sd">		:return: Filtered sequence list in the attribute :py:attr:`sequences`</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">filter_unnatural</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="PeptideDescriptor.filter_values"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.PeptideDescriptor.filter_values">[docs]</a>	<span class="k">def</span> <span class="nf">filter_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s1">&#39;==&#39;</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Method to filter the descriptor matrix in the attribute :py:attr:`descriptor` for a given list of value (same</span>
<span class="sd">		size as the number of features in the descriptor matrix!)</span>

<span class="sd">		:param values: List of values to filter</span>
<span class="sd">		:param operator: filter criterion, available are all SQL like operators: ``==``, ``&lt;``, ``&gt;``, ``&lt;=``and ``&gt;=``.</span>
<span class="sd">		:return: filtered descriptor matrix and updated sequences in the corresponding attributes.</span>

<span class="sd">		.. seealso:: :func:`modlamp.core.filter_values()`</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">filter_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">operator</span><span class="p">)</span></div>

<div class="viewcode-block" id="PeptideDescriptor.filter_aa"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.PeptideDescriptor.filter_aa">[docs]</a>	<span class="k">def</span> <span class="nf">filter_aa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aminoacids</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]):</span>
		<span class="sd">&quot;&quot;&quot;Method to filter sequences and corresponding descriptor values, if the sequences contain any of the given</span>
<span class="sd">		amino acids in the argument list **aminoacids**.</span>

<span class="sd">		:param aminoacids: List/array of amino acids to filter for</span>
<span class="sd">		:return: filtered descriptor matrix and updated sequences and names in the corresponding attributes.</span>

<span class="sd">		.. seealso:: :func:`modlamp.core.filter_aa_more()`</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">filter_aa_more</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aminoacids</span><span class="p">)</span></div>

<div class="viewcode-block" id="PeptideDescriptor.load_descriptordata"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.PeptideDescriptor.load_descriptordata">[docs]</a>	<span class="k">def</span> <span class="nf">load_descriptordata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="n">targets</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Method to load any data file with sequences and descriptor values and save it to a new insatnce of the</span>
<span class="sd">		class :class:`modlamp.descriptors.PeptideDescriptor`.</span>

<span class="sd">		.. note::</span>
<span class="sd">			The data file should **not** have any headers</span>

<span class="sd">		:param filename: filenam of the data file to be loaded</span>
<span class="sd">		:param delimiter: column delimiter</span>
<span class="sd">		:param targets: {boolean} whether last column in the file contains a target class vector</span>
<span class="sd">		:return: loaded sequences, descriptor values and targets in the corresponding attributes.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="n">delimiter</span><span class="p">)</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span>  <span class="c1"># skip sequences as they are &quot;nan&quot; when read as float</span>
		<span class="n">seqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="n">delimiter</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;str&quot;</span><span class="p">)</span>
		<span class="n">seqs</span> <span class="o">=</span> <span class="n">seqs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">targets</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">sequences</span> <span class="o">=</span> <span class="n">seqs</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">data</span></div>

<div class="viewcode-block" id="PeptideDescriptor.save_descriptor"><a class="viewcode-back" href="../../modlamp.html#modlamp.descriptors.PeptideDescriptor.save_descriptor">[docs]</a>	<span class="k">def</span> <span class="nf">save_descriptor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">targets</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Method to save the descriptor values to a .csv/.txt file</span>

<span class="sd">		:param filename: filename of the output file</span>
<span class="sd">		:param delimiter: column delimiter</span>
<span class="sd">		:param targets: target class vector to be added to descriptor (same length as :py:attr:`sequences`)</span>
<span class="sd">		:return: output file with peptide names and descriptor values</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;|S80&#39;</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">targets</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">):</span>
			<span class="n">target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">targets</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
			<span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">target</span><span class="p">))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">))</span>
		<span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="n">delimiter</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">)</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/modlab.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">modlamp v2.2.1 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, modlab ETH Zurich, Alex Mueller.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.5.
    </div>
  </body>
</html>